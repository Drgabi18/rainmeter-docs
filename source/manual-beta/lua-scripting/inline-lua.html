---
layout: manual-beta
permalink: manual-beta/lua-scripting/inline-lua/
title: 'Inline Lua'
---
<p>Functions in a Lua script may be executed "inline", by using a call to the function as a <a href="!variables/section-variables/">[SectionVariable]</a>, referencing the <a href="!measures/script/">Script measure</a> containing the <code>ScriptFile</code> option for the .lua file, and a reference to a single function() within the Lua script, with optional number or string parameters.</p>

<p>The Lua function will be executed, using the provided number or string parameters, and the single number or string value returned by the function() in the Lua script will replace the [Section Variable] where it is used.</p>

<p>The way to consider this is that this is a simple [SectionVariable], and works just like any other [SectionVariable]. The only difference is that a [SectionVariable] is used to reference a number or string value returned by some measure in the skin, and this is used to reference a number or string value returned by some function() in the Lua hosted by a Script measure in the skin.<p>

<p>As the inline Lua can reference any function() within the .lua file, and can pass parameters specific to where the inline Lua is used, a single Script measure can host any number of functions, and those functions can return values specific to where you use them.</p>

<p>These may be used anywhere a [SectionVariable] is allowed. This can be in almost any options in <a href="!measures/">measures</a> or <a href="!meters/">meters</a>, and any <a href="!bangs/">bangs</a> in an <a href="!skins/option-types/#Action">action</a>.</p>

<p>As with any [SectionVariable], these will be resolved, in this case executed, when the skin is loaded, and on each update of the measure or meter containing them. As with any [SectionVariable], <code>DynamicVariables=1</code> must be used on any measure or meter containing them.</p>

<p>Note that this is not designed to execute stand-alone Lua statements, but is used to execute a function() code block in the Lua script file that returns a value. For example:</p>

```txt
function SomeFunction(arg1, arg2)
	outValue = arg1 + arg2
	return outValue
end
```

<h2  id="NestedVariables">Nested variables</h2>

<p>It must be remembered that the entire inline Lua functionality is contained within a [SectionVariable]. This means that any #Variable# or other measure [SectionVariable] you use in the parameters to the Lua function will cause "nesting" of variables within variables. The standard way of expressing #VariableName# and / or [MeasureName] in Rainmeter cannot be "nested", and won't work.</p>

<p>This is solved by using the alternative <a href="!variables/nesting-variables/">Nesting Variables</a> syntax in any inline Lua. That link has a full explanation, but in short:</p>

<p><table class="table-striped">	
	<tr><td><b>[#VarName]</b></td><td>&nbsp;&nbsp;&nbsp;</td><td>Replaces: #VarName#</td></tr>
	<tr><td><b>[&MeasureName]</b></td><td>&nbsp;&nbsp;&nbsp;</td><td>Replaces: [MeasureName]</td></tr>
	<tr><td><b>[$MouseVar]</b></td><td>&nbsp;&nbsp;&nbsp;</td><td>Replaces: $MouseVar$</td></tr>
</table></p>

<p>In general, anything useful that you do with this functionality is going to entail passing variables of one form or another to the Lua function, and just always using the Nested Variables syntax with any inline Lua will save a lot of frustration and confusion.</p>

<h2 id="UsingInlineLua">Using inline Lua</h2>

<p>The syntax of an inline Lua section variable is:</code>

<p><code>[&ScriptMeasureName:LuaFunctionName(numberParameter, 'stringParameter', ...)]</code></p>

<p>Examples:<br/>
<code>[&MeasureMyScript:GetCharaceterInString('Rainmeter', 5)]</code><br/>
<code>[&MeasureMyScript:ConvertTemperature([&MeasureCurrentTemp], 'C')]</code></p>

<p>String values in parameters must be explicitly passed as strings to the Lua function, by enclosing them in 'single quotes'. Numbers or formulas may, and should, be passed without quotes, but any string passed without quoting will be seen by the Lua as a Lua variable name with a nil value, and will fail.</p>

<p>The Lua boolean data types may be passed to the Lua function with <code>true</code> or <code>false</code>, and any <code>return</code> to Rainmeter of a boolean <code>true</code> will be 1 and <code>false</code> will be 0.</code>

<p>The inline Lua section variable will be replaced by a single number or string value, which must be passed back to Rainmeter using the <code>return</code> function in the Lua.</p>

<p>The best way to explain this is to disassemble a few simple examples.</p>

<h2 id="SimpleLua">SimpleLua</h2>

<p>SimpleLua.ini:</p>
```txt
[Rainmeter]
Update=1000
AccurateText=1
DynamicWindowSize=1

[MeasureGetUserName]
Measure=Plugin
Plugin=SysInfo
SysInfoType=USER_NAME
UpdateDivider=-1

[MeasureScript]
Measure=Script
ScriptFile=SimpleLua.lua
Disabled=1

[MeterWelcome]
Meter=String
FontSize=20
FontWeight=400
FontColor=255,255,255,255
SolidColor=47,47,47,255
Padding=5,5,5,5
AntiAlias=1
Text=[&MeasureScript:GetWelcome('[&MeasureGetUserName]')]
DynamicVariables=1
```
<p>So we have a pretty simple skin, which gets the name of the user account logged into Windows with the <code>SysInfoType=USER_NAME</code> option on the SysInfo plugin measure [MeasureGetUserName].</p>

<p>And we have a Script measure, [MeasureScript], which will load and make available the Lua script file SimpleLua.lua. Note that since we don't use or need an Update() function in the Lua, we can just disable this Script measure. There is nothing it can or should return on each update of the measure itself.</p>

<p>Then in our [MeterWelcome] String meter, we use an inline Lua section variable. Let's look at the construction of that.</p>

<p><code>Text=[&MeasureScript:GetWelcome('[&MeasureGetUserName]')]</code></p>

<p>First, we reference our Script measure name with <code>[&MeasureScript</code>. That is followed with a <code>:</code> colon, to indicate a modifier, as with any [SectionVariable]. Note that we are using the Nested Variables syntax to reference our Script measure, as we are going to be "nesting" another [SectionVariable] in this.</p>

<p>Then we reference the function() in the Lua script file that we want to call. In this case it is a function called <code>GetWelcome()</code>, which requires a 'string' parameter.</p>

<p>We want to use the value of our [MeasureGetUserName] measure as the 'string' parameter to the Lua function, so we use the Nested Variables syntax to pass the value of that measure to the Lua as a 'string', with the section variable <code>('[&MeasureGetUserName]')</code>. Then we end the initial section variable, our inline Lua, with a <code>]</code> square bracket.</p>

<p>SimpleLua.lua:</p>

```txt
function GetWelcome(inArg)

	hourOfDay = tonumber(os.date('%H'))
	
	if hourOfDay < 12 then
		greetingText = 'Good Morning'
	elseif hourOfDay < 17 then
		greetingText = 'Good Afternoon'
	else
		greetingText = 'Good Evening'
	end

	welcomeText = greetingText..', '..inArg

	return welcomeText

end
```

<p>If we pretend that the value of our [MeasureGetUserName] measure is the string <code>RainmeterTeam</code>, then the function <code>GetWelcome('RainmeterTeam')</code> will be executed in the Lua script.</p>

<p>The Lua script uses the current hour to choose a greeting appropriate for the time of day, and constructs a string to return as the section variable value to the String meter in Rainmeter. That is done with the <code>return</code> function in Lua, as <code>return welcomeText</code>. What would be seen in the skin at nine in the morning is "Good Morning, RainmeterTeam".

<h2 id="FlipCoin">FlipCoin</h2>

<p>This example is a little more complex, showing how we can combine the use of an "action" in the Rainmeter skin, with inline Lua section variables, to get a result "on demand", and how we can use more than one function() in the same Lua script file.</p>

<p>With this one, we will just explain using ;comments in the Rainmeter code, and --comments in the Lua code, as it might be easier to follow the explanation in context.</p>

<p>FlipCoin.ini:</p>

```txt
[Rainmeter]
Update=1000
DynamicWindowSize=1
AccurateText=1

[MeasureScript]
Measure=Script
ScriptFile=FlipCoin.lua
; There is no Update() function in the Lua, and we don't need
; one, so there is no reason to enable this measure. It's a 
; "host" for the .lua file we use with !CommandMeasure and
; inline Lua later on.
Disabled=1

[MeterFlip]
Meter=String
FontSize=13
FontWeight=400
FontColor=255,255,255,255
SolidColor=47,47,47,255
Padding=5,5,5,5
AntiAlias=1
Text=Flip Coin
; We don't want the coin to flip on every update of the skin, or the meters with 
; the inline Lua section variables, we want to flip the coin on demand. So we
; Use a !CommandMeasure bang with a LeftMouseUpAction to execute the 
; FlipCoin() function in the Lua, which will get a random number between 0 and 1, 
; and set the value of the coin to "heads" or "tails".
LeftMouseUpAction=[!CommandMeasure MeasureScript "FlipCoin()"][!UpdateMeterGroup Coins][!Redraw]

[MeterCoin]
Meter=String
Group=Coins
X=15R
FontSize=20
FontWeight=700
FontColor=255,255,255,255
SolidColor=0,0,0,1
AntiAlias=1
; Now we use an inline Lua section variable to ask for the current value,
; 'Heads' or 'Tails' of the coin, using the GetCoin() function in the Lua.
; This will get that value, which was created and changed by FlipCoin() and
; is "global", and replace the inline Lua section variable in the Text
; option of the meter.
Text=It's [&MeasureScript:GetCoin()]
DynamicVariables=1

[MeterCount]
Meter=String
Group=Coins
X=0
Y=10R
FontSize=17
FontWeight=400
FontColor=255,255,255,255
SolidColor=0,0,0,1
AntiAlias=1
; And as an added bonus, when we flip the coin with our !CommandMeasure action, the
; Lua also keeps track of how many times it was 0 or 1. We can then ask the
; function GetCount() to return either the number of 'Heads' or 'Tails' and those
; values will replace the inline Lua section variables in the Text option.
Text=Heads: [&MeasureScript:GetCount('Heads')]  Tails: [&MeasureScript:GetCount('Tails')]
DynamicVariables=1
```

<p>FlipCoin.lua:</p>

```txt
math.randomseed(tonumber(tostring(os.time()):reverse():sub(1,6)))
	
function FlipCoin()

	flipNumber = math.random(0, 1)
	
	if flipNumber == 0 then
		flipText = 'Heads'
		headsCount = headsCount + 1
	else
		flipText = 'Tails'
		tailsCount = tailsCount + 1
	end

end
	
function GetCoin()

	-- If FlipCoin() hasn't been executed yet, flipText will be nil. We can't return nil to 
	-- Rainmeter, so we need to set it to some string initially. 
	flipText = flipText or 'None'
	
	return flipText

end

function GetCount(faceArg)

	-- If FlipCoin() hasn't been executed yet, the counts will be nil. We can't return nil to 
	-- Rainmeter, so we need to set them to 0 initially. 
	headsCount = headsCount or 0
	tailsCount = tailsCount or 0
	
	if string.lower(faceArg) == 'heads' then
		return headsCount
	else
		return tailsCount
	end

end	
```

<h2 id="TranslateDay">TranslateDay</h2>

<p>This example adds a few more pieces, showing how we can use both [&SectionVariables] and [#Variables] (remember our Nesting Variables syntax!) embedded in the inline Lua, and how to pass multiple parameters to the Lua function, both number and 'string'.</p>

<p>TranslateDay.ini:</p>

```txt
[Rainmeter]
Update=1000
AccurateText=1
DynamicWindowSize=1

[Variables]
MainLang=English

[MeasureDay]
Measure=Time
Format=%w

[MeasureScript]
Measure=Script
ScriptFile=TranslateDay.lua
; We are not doing anything on every skin update, and there is no Update() function
; in the .lua file, so there is no need to enable this measure. In this case, it's
; just a "host" for the function() in the script we will call "inline" later.
Disabled=1

[MeterBack]
Meter=Shape
Shape=Rectangle 0.5,0.5,220,110,12 | Fill Color 47,47,47,255 | StrokeWidth 1.5 | Stroke Color 150,150,150,255

[MeterHeader]
Meter=String
X=10
Y=10
FontSize=13
FontWeight=400
FontColor=255,255,255,255
AntiAlias=1
; In this we use an inline Lua variable to call the TranslateHeader() function hosted
; by our [MeasureScript] measure, and pass it the the string for the variable [#MainLang].
; It will "return" the result, a lookup translation of the text "Today is", and replace that
; in the value of the Text option.
Text=[&MeasureScript:TranslateHeader('[#MainLang])']
DynamicVariables=1

[MeterLang1]
Meter=String
X=10
Y=10R
FontSize=11
FontWeight=400
FontColor=255,255,255,255
AntiAlias=1
; In this we use an inline Lua variable to call the TranslateDayOfWeek() function hosted
; by our [MeasureScript] measure, pass it the day of the week as a number, and 
; the string 'Language'. It will "return" the result and replace that in the value
; of the Text option.

; Note that [&MeasureDay] represents a number and we pass it as a number. The value of
; the variable [#MainLang] is a string, and we pass it as a string with single quotes.
Text=[#MainLang]:		[&MeasureScript:TranslateDayOfWeek([&MeasureDay], '[#MainLang]')]
DynamicVariables=1

[MeterLang2]
Meter=String
X=0r
Y=5R
FontSize=11
FontWeight=400
FontColor=255,255,255,255
AntiAlias=1
; This is were the power of this feature shines. Note that since we are 
; passing different "parameters" to the function in different places where
; we "use it", the result can be specifically tailored to the context
; it it used in. So "English" before, and "French" here...
Text=French:		[&MeasureScript:TranslateDayOfWeek([&MeasureDay], 'French')]
DynamicVariables=1

[MeterLang3]
Meter=String
X=0r
Y=5R
FontSize=11
FontWeight=400
FontColor=255,255,255,255
AntiAlias=1
Text=Russian:		[&MeasureScript:TranslateDayOfWeek([&MeasureDay], 'Russian')]
DynamicVariables=1
```

<p>TranslateDay.lua:</p>

```txt
function Initialize()

	translateToday = {
	english = 'Today is',
	german = 'Heute ist',
	french = 'Aujourd\'hui, c\'est',
	spanish = 'Hoy es',
	russian = 'Cегодня'
	}
	
	translateDays = {
	english = {'Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'},
	german = {'Sonntag','Montag','Dienstag','Mittwoch','Donnerstag','Freitag','Samstag'},
	french = {'dimanche','lundi','mardi','mercredi','jeudi','vendredi','samedi'},
	spanish = {'domingo','lunes','martes','mercredi','miércoles','viernes','sábado'},
	russian = {'воскресенье','понедельник','вторник','среда','четверг','пятница'}
	}

end

function TranslateHeader(langArg)

	return translateToday[string.lower(langArg)]
	
end

function TranslateDayOfWeek(dayArg, langArg)

	return translateDays[string.lower(langArg)][dayArg+1]
	
end
```

<p>In these examples, we concentrated on using the inline Lua to set Text options on a String meter, as they are easy to understand and demonstrate. Remember though, that inline Lua can be used on any measure or meter option, and in any bang. Anywhere that a [SectionVariable] can be used. So this might be X or FontColor on a String meter, Drive on a FreeDiskSpace measure, some value in an ActionTimer measure, the uses are only limited by how clever you are.</p>

<h2 id="DownloadExamples">Download Examples</h2>

<p>You can download the above examples, and a few others, as a .rmskin.</p>

<div float="left">

</div>
<div class="exampleprev">
	<a href="!examples/ExampleInlineLua.rmskin"><img src="!img/inline-lua/ExampleInlineLau.png"></a>
</div>